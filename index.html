<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<title>Matrix Hide and Seek — Standalone</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; height:100%; background:#000; font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; color:#fff; }
  canvas { display:block; width:100vw; height:100dvh; background:#000; }
  #hud {
    position:fixed; inset:auto 0 auto 0; top:env(safe-area-inset-top); display:flex; align-items:center; justify-content:space-between;
    padding:8px 12px; font-size:clamp(12px,1.8vw,16px); pointer-events:none; opacity:.9; z-index:10;
  }
  #hud .group { display:flex; gap:10px; }
  #stealthBar { position:fixed; left:12px; bottom:calc(12px + env(safe-area-inset-bottom)); width:160px; height:8px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.12); border-radius:4px; overflow:hidden; z-index:10; }
  #stealthFill { height:100%; width:0%; background:#7cffa3; }
  #minimap {
    position:fixed; right:12px; top:calc(52px + env(safe-area-inset-top)); width:160px; height:160px;
    border:1px solid rgba(255,255,255,.25); background:rgba(0,0,0,.35); backdrop-filter:blur(2px);
    pointer-events:none; z-index:10;
  }
  #overlay {
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; text-align:center;
    background:rgba(0,0,0,.6); backdrop-filter:blur(2px); z-index:20;
  }
  #overlay .panel { border:1px solid #fff; background:rgba(0,0,0,.25); padding:18px 20px; max-width:720px; }
  button {
    background:#0b0b0b; color:#fff; border:1px solid #2a2a2a; border-radius:6px; padding:8px 10px; cursor:pointer;
    transition:transform .05s ease;
  }
  button:active { transform:translateY(1px); }
  .row { display:flex; gap:8px; align-items:center; justify-content:center; }
  .col { display:flex; flex-direction:column; gap:8px; align-items:stretch; }
  label.switch { display:flex; align-items:center; justify-content:space-between; gap:12px; }
  input[type="checkbox"] { transform:scale(1.2); }
</style>
</head>
<body>
  <div id="hud">
    <div class="group"><span id="level"></span><span id="status"></span></div>
    <div class="group"><span id="fps"></span></div>
  </div>
  <div id="stealthBar"><div id="stealthFill"></div></div>
  <canvas id="minimap" width="160" height="160"></canvas>
  <div id="overlay"><div class="panel" id="overlayText"></div></div>
  <canvas id="game"></canvas>

<script>
(() => {
  // ---------- utilities ----------
  const TAU = Math.PI*2;
  const lerp = (a,b,t) => a+(b-a)*t;
  const clamp = (v,a,b) => v<a?a:(v>b?b:v);
  const dist2 = (x1,y1,x2,y2) => { const dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy; };
  const rnd = (min,max) => min + Math.random()*(max-min);
  const rndInt = (min,max) => (min + Math.floor(Math.random()*(max-min+1)));
  const choice = (arr) => arr[(Math.random()*arr.length)|0];
  const isCoarsePointer = () => window.matchMedia && window.matchMedia('(pointer:coarse)').matches;

  // vibrate if available
  const haptics = (ms=15) => { try { navigator.vibrate && navigator.vibrate(ms); } catch {} };

  // ---------- canvas and DPR ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha:false });
  const hudLevel = document.getElementById('level');
  const hudStatus = document.getElementById('status');
  const hudFps = document.getElementById('fps');
  const stealthFill = document.getElementById('stealthFill');
  const overlay = document.getElementById('overlay');
  const overlayText = document.getElementById('overlayText');
  const minimapEl = document.getElementById('minimap');
  const mm = minimapEl.getContext('2d');

  let DPR = Math.min(3, window.devicePixelRatio || 1);
  let renderScale = 1.0;
  let scale = DPR * renderScale;
  const W = () => canvas.width / scale;
  const H = () => canvas.height / scale;
  function fitCanvas() {
    const vw = Math.max(1, window.innerWidth);
    const vh = Math.max(1, window.innerHeight);
    DPR = Math.min(3, window.devicePixelRatio || 1);
    scale = DPR * renderScale;
    canvas.style.width = vw+'px'; canvas.style.height = vh+'px';
    canvas.width = Math.round(vw*scale); canvas.height = Math.round(vh*scale);
  }
  function setRenderScale(s) {
    renderScale = clamp(s, 0.7, 1.0);
    fitCanvas();
  }
  window.addEventListener('resize', fitCanvas, { passive:true });
  fitCanvas();

  // ---------- input ----------
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if(['arrowup','arrowdown','arrowleft','arrowright','w','a','s','d'].includes(k)) e.preventDefault();
    keys.add(k);
    if(k==='r') game.running ? game.resetLevel() : game.startNewRun();
    if(k==='v') { game.minimapOn = !game.minimapOn; minimapEl.style.display = game.minimapOn?'block':'none'; }
    if(k==='p') game.togglePause();
    if(k==='z') game.autoMode = !game.autoMode;
    if(k==='m') game.debug = !game.debug;
    if(k==='o') game.showSettings();
    if(k==='n') game.sfx.toggleMute();
  }, { passive:false });
  window.addEventListener('keyup', (e)=> keys.delete(e.key.toLowerCase()), { passive:true });

  // touch joystick
  const joystick = { active:false, cx:0, cy:0, x:0, y:0, radius:84, dead:10, max:72, vec:[0,0], mag:0 };
  function pointerPos(e){ const t=e.touches?e.touches[0]:e; const r=canvas.getBoundingClientRect(); return {x:t.clientX-r.left, y:t.clientY-r.top}; }
  function startJoy(e){ if(game.overlayActive) return; const p=pointerPos(e); joystick.active=true; joystick.cx=joystick.x=p.x; joystick.cy=joystick.y=p.y; joystick.vec=[0,0]; joystick.mag=0; }
  function moveJoy(e){ if(!joystick.active) return; const p=pointerPos(e); const dx=p.x-joystick.cx, dy=p.y-joystick.cy; const d=Math.hypot(dx,dy); const a=Math.atan2(dy,dx);
    const c=Math.min(joystick.max, d); joystick.x=joystick.cx+Math.cos(a)*c; joystick.y=joystick.cy+Math.sin(a)*c;
    if(d<joystick.dead){ joystick.vec=[0,0]; joystick.mag=0; } else { joystick.mag=clamp((d-joystick.dead)/(joystick.max-joystick.dead),0,1); joystick.vec=[Math.cos(a),Math.sin(a)]; }
  }
  function endJoy(){ joystick.active=false; joystick.vec=[0,0]; joystick.mag=0; }
  canvas.addEventListener('pointerdown', startJoy, { passive:false });
  canvas.addEventListener('pointermove', moveJoy, { passive:false });
  window.addEventListener('pointerup', endJoy, { passive:true });
  window.addEventListener('pointercancel', endJoy, { passive:true });

  // ---------- geometry ----------
  function rectsIntersect(a,b){ return !(a.x+a.w<b.x||b.x+b.w<a.x||a.y+a.h<b.y||b.y+b.h<a.y); }
  function circleRectCollide(cx,cy,cr,r){ const x=clamp(cx,r.x,r.x+r.w), y=clamp(cy,r.y,r.y+r.h); const dx=cx-x, dy=cy-y; return dx*dx+dy*dy<=cr*cr; }
  function segIntersect(ax,ay,bx,by,cx,cy,dx,dy){ const rpx=bx-ax,rpy=by-ay,spx=dx-cx,spy=dy-cy,den=(-spx*rpy+rpx*spy); if(den===0) return false;
    const s=(-rpy*(ax-cx)+rpx*(ay-cy))/den; const t=(spx*(ay-cy)-spy*(ax-cx))/den; return s>=0&&s<=1&&t>=0&&t<=1; }
  function lineRectIntersect(x1,y1,x2,y2,r){
    const x3=r.x,y3=r.y,x4=r.x+r.w,y4=r.y+r.h;
    return segIntersect(x1,y1,x2,y2,x3,y3,x4,y3) || segIntersect(x1,y1,x2,y2,x4,y3,x4,y4) ||
           segIntersect(x1,y1,x2,y2,x4,y4,x3,y4) || segIntersect(x1,y1,x2,y2,x3,y4,x3,y3);
  }

  // ---------- audio ----------
  class Sfx {
    constructor(){ this.ctx=null; this.master=null; this.muted=false; }
    init(){ if(this.ctx) return; try{ this.ctx=new (window.AudioContext||window.webkitAudioContext)(); }catch{} if(!this.ctx) return;
      this.master=this.ctx.createGain(); this.master.gain.value=this.muted?0:1; this.master.connect(this.ctx.destination);
    }
    toggleMute(){ this.muted=!this.muted; if(this.master) this.master.gain.value=this.muted?0:1; }
    tone(freq=440, dur=0.08, type='sine', gain=0.03){
      if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); const g=this.ctx.createGain();
      o.type=type; o.frequency.value=freq; o.connect(g); g.connect(this.master);
      g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(gain,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.start(t); o.stop(t+dur+0.05);
    }
    click(){ this.tone(880,0.05,'square',0.02); }
    alert(){ this.tone(640,0.07,'sine',0.03); setTimeout(()=>this.tone(760,0.06,'sine',0.03),90); }
    caught(){ this.tone(200,0.18,'sawtooth',0.05); }
    exit(){ this.tone(1200,0.08,'triangle',0.05); setTimeout(()=>this.tone(1500,0.08,'sine',0.04),90); }
    tickStart(){
      if(!this.ctx) return; if(this._tick) return;
      const o=this.ctx.createOscillator(), g=this.ctx.createGain(); o.type='triangle'; o.frequency.value=3; g.gain.value=0.02;
      o.connect(g); g.connect(this.master); o.start(); this._tick=o;
    }
    tickStop(){ try{ this._tick && this._tick.stop(); }catch{} this._tick=null; }
  }

  // ---------- grid for nav ----------
  const GRID = 16;
  class Grid {
    constructor(obstacles, agentRadius){
      this.cs = GRID;
      this.cols = Math.max(3, Math.floor(W()/this.cs));
      this.rows = Math.max(3, Math.floor(H()/this.cs));
      this.blocked = new Uint8Array(this.cols*this.rows);
      for(let gy=0; gy<this.rows; gy++){
        for(let gx=0; gx<this.cols; gx++){
          let idx=gy*this.cols+gx;
          if(gx<=0||gy<=0||gx>=this.cols-1||gy>=this.rows-1){ this.blocked[idx]=1; continue; }
          const cx=gx*this.cs+this.cs*0.5, cy=gy*this.cs+this.cs*0.5;
          let block=false;
          for(const o of obstacles){ if(circleRectCollide(cx,cy,agentRadius+2,o)){ block=true; break; } }
          this.blocked[idx]=block?1:0;
        }
      }
    }
    inBounds(gx,gy){ return gx>=0 && gy>=0 && gx<this.cols && gy<this.rows; }
    isBlocked(gx,gy){ return this.blocked[gy*this.cols+gx]===1; }
    cellOf(x,y){ return { gx:Math.floor(x/this.cs), gy:Math.floor(y/this.cs) }; }
    toWorld(gx,gy){ return { x:gx*this.cs+this.cs*0.5, y:gy*this.cs+this.cs*0.5 }; }
    neighbors(gx,gy){
      const ns=[];
      for(let oy=-1; oy<=1; oy++) for(let ox=-1; ox<=1; ox++){
        if(!ox && !oy) continue;
        const nx=gx+ox, ny=gy+oy;
        if(!this.inBounds(nx,ny)) continue;
        if(this.isBlocked(nx,ny)) continue;
        if(ox && oy && (this.isBlocked(gx+ox,gy) || this.isBlocked(gx,gy+oy))) continue;
        ns.push({gx:nx, gy:ny, w:(ox===0||oy===0)?1:Math.SQRT2});
      }
      return ns;
    }
    losClear(x1,y1,x2,y2, obstacles){
      for(const o of obstacles){ if(lineRectIntersect(x1,y1,x2,y2,o)) return false; }
      return true;
    }
  }
  // simple A* on main thread
  function astar(grid, x1,y1, x2,y2){
    const s=grid.cellOf(x1,y1), g=grid.cellOf(x2,y2);
    if(!grid.inBounds(s.gx,s.gy)||!grid.inBounds(g.gx,g.gy)) return null;
    if(grid.isBlocked(g.gx,g.gy)) return null;
    const idx=(gx,gy)=> gy*grid.cols+gx;
    const open=[]; const push=(n)=>{ open.push(n); let i=open.length-1; while(i>0){ const p=(i-1)>>1; if(open[i].f<open[p].f){ [open[i],open[p]]=[open[p],open[i]]; i=p; } else break; } };
    const pop=()=>{ if(open.length===0) return null; const t=open[0]; const v=open.pop(); if(open.length>0){ open[0]=v; let i=0; for(;;){ let l=i*2+1,r=l+1,s=i; if(l<open.length && open[l].f<open[s].f) s=l; if(r<open.length && open[r].f<open[s].f) s=r; if(s===i) break; [open[i],open[s]]=[open[s],open[i]]; i=s; } } return t; };
    const cameX=new Int16Array(grid.cols*grid.rows).fill(-1), cameY=new Int16Array(grid.cols*grid.rows).fill(-1);
    const gScore=new Float32Array(grid.cols*grid.rows); gScore.fill(1e9);
    const fScore=new Float32Array(grid.cols*grid.rows); fScore.fill(1e9);
    const heur=(ax,ay,bx,by)=>{ const dx=Math.abs(ax-bx), dy=Math.abs(ay-by); const dmin=Math.min(dx,dy), dmax=Math.max(dx,dy); return (dmax-dmin)+Math.SQRT2*dmin; };
    const startI=idx(s.gx,s.gy), goalI=idx(g.gx,g.gy);
    gScore[startI]=0; fScore[startI]=heur(s.gx,s.gy,g.gx,g.gy); push({gx:s.gx, gy:s.gy, f:fScore[startI]});
    const closed=new Uint8Array(grid.cols*grid.rows); let explored=0, maxNodes=Math.min(grid.cols*grid.rows, 4000);
    while(open.length && explored++<maxNodes){
      const cur=pop(); const ci=idx(cur.gx,cur.gy); if(closed[ci]) continue;
      if(ci===goalI){
        const path=[]; let cx=cur.gx, cy=cur.gy;
        while(!(cx===s.gx && cy===s.gy)){ path.push(grid.toWorld(cx,cy)); const pi=idx(cx,cy); const px=cameX[pi], py=cameY[pi]; if(px<0) break; cx=px; cy=py; }
        path.push(grid.toWorld(s.gx,s.gy)); path.reverse();
        const stride=Math.max(1, Math.floor(path.length/120)); const out=[]; for(let i=0;i<path.length;i+=stride) out.push(path[i]); if(path.length && out[out.length-1]!==path[path.length-1]) out.push(path[path.length-1]);
        return out;
      }
      closed[ci]=1;
      for(const n of grid.neighbors(cur.gx,cur.gy)){
        const ni=idx(n.gx,n.gy); if(closed[ni]) continue; const t=gScore[ci]+n.w;
        if(t<gScore[ni]){ cameX[ni]=cur.gx; cameY[ni]=cur.gy; gScore[ni]=t; fScore[ni]=t+heur(n.gx,n.gy,g.gx,g.gy); push({gx:n.gx,gy:n.gy,f:fScore[ni]}); }
      }
    }
    return null;
  }

  // ---------- entities ----------
  const PLAYER_R = 12;
  const BOT_R = 14;

  class Player {
    constructor(pos){ this.x=pos.x; this.y=pos.y; this.vx=0; this.vy=0; this.r=PLAYER_R; }
    update(dt, cfg){
      const [ix,iy,mag] = inputVector();
      const dashMul = game.dashTimer>0 ? 1.8 : 1;
      const sneakMul = game.sneak ? 0.58 : 1;
      const accel = cfg.playerSpeed * dashMul * sneakMul * (0.7+0.3*mag);
      this.vx += ix*accel*dt; this.vy += iy*accel*dt;
      this.vx *= cfg.playerFriction; this.vy *= cfg.playerFriction;
      const sp=Math.hypot(this.vx,this.vy), max=cfg.playerMaxSpeed*(dashMul>1?1.5:1)*sneakMul; if(sp>max){ const f=max/sp; this.vx*=f; this.vy*=f; }
      let nx=this.x+this.vx*dt, ny=this.y+this.vy*dt;
      if(nx<this.r){ nx=this.r; this.vx=0; } if(ny<this.r){ ny=this.r; this.vy=0; }
      if(nx>W()-this.r){ nx=W()-this.r; this.vx=0; } if(ny>H()-this.r){ ny=H()-this.r; this.vy=0; }
      const obs = game.nearbyObstacles(nx,ny,this.r+3);
      for(const o of obs){
        if(circleRectCollide(nx,ny,this.r,o)){
          const tryX=this.x+this.vx*dt; if(!circleRectCollide(tryX,this.y,this.r,o)){ nx=tryX; ny=this.y; this.vy=0; }
          else { const tryY=this.y+this.vy*dt; if(!circleRectCollide(this.x,tryY,this.r,o)){ ny=tryY; nx=this.x; this.vx=0; }
          else { const dx=this.x-(o.x+o.w*0.5), dy=this.y-(o.y+o.h*0.5); const L=Math.hypot(dx,dy)||1; nx=this.x+dx/L*2; ny=this.y+dy/L*2; this.vx*=0.5; this.vy*=0.5; } }
        }
      }
      this.x=nx; this.y=ny;
    }
    draw(ctx){
      ctx.save();
      const col = game.cloakTimer>0 ? 'rgba(255,255,255,0.25)' : '#ffffff';
      ctx.shadowColor=col; ctx.shadowBlur=12*scale; ctx.fillStyle=col;
      ctx.beginPath(); ctx.arc(this.x*scale,this.y*scale,this.r*scale,0,TAU); ctx.fill();
      ctx.restore();
    }
  }

  function botColor(kind){
    return kind==='stalker' ? '#66aaff'
         : kind==='phase'   ? '#99ff99'
         : '#ff2a2a';
  }

  class Bot {
    constructor(pos, kind='hunter'){
      this.x=pos.x; this.y=pos.y; this.vx=0; this.vy=0; this.r=BOT_R;
      this.state='patrol'; this.path=[]; this.i=0; this.lastSeen=null; this.patrol=[];
      this.kind=kind; this.recalcT=0;
    }
    setPatrol(grid){
      this.patrol.length=0;
      for(let i=0;i<4;i++){
        const gx=rndInt(2,grid.cols-3), gy=rndInt(2,grid.rows-3);
        if(!grid.isBlocked(gx,gy)) this.patrol.push(grid.toWorld(gx,gy));
      }
    }
    canSee(player, obstacles, cfg){
      if(this.kind==='stalker') return true;
      const dx=player.x-this.x, dy=player.y-this.y;
      const sr = cfg.botSightRange * (0.9 + game.noise*0.3);
      if(dx*dx+dy*dy > sr*sr) return false;
      if(!game.grid.losClear(this.x,this.y,player.x,player.y,obstacles)) return false;
      const heading = Math.atan2(this.vy||0.0001, this.vx||0.0001);
      const dir = Math.atan2(dy,dx);
      const fov = cfg.botFOV * (1.0 - 0.15*clamp(1-game.noise,0,1));
      let ang=Math.abs(((dir-heading+TAU*1.5)%TAU)-Math.PI);
      return ang <= fov*0.5;
    }
    canHear(player,cfg){
      if(this.kind==='stalker') return false;
      const sp = Math.hypot(player.vx,player.vy);
      const r = cfg.botHearing * (0.4 + 0.9*game.noise);
      return sp>10 && dist2(this.x,this.y,player.x,player.y) <= r*r;
    }
    update(dt, cfg){
      const p=game.player, grid=game.grid, obs=game.obstacles;
      const freeze = game.freezeTimer>0 ? 0 : 1;
      const baseSpeed = (cfg.playerMaxSpeed*0.92) * game.botSpeedMul;
      const speed = freeze===0 ? 0 : (this.kind==='stalker' ? baseSpeed*0.6 : baseSpeed);
      // perception
      const seen = this.canSee(p, obs, cfg);
      const heard = this.canHear(p, cfg);
      if(seen){ this.state='chase'; this.lastSeen={x:p.x,y:p.y}; }
      else if(this.state!=='chase' && heard){ this.state='search'; this.lastSeen={x:p.x,y:p.y}; }
      // decision
      this.recalcT -= dt;
      if(this.state==='chase'){
        if(grid.losClear(this.x,this.y,p.x,p.y,obs)){ this.seek(p.x,p.y, speed, dt*freeze); }
        else {
          if(this.recalcT<=0){ this.path = astar(grid,this.x,this.y,p.x,p.y) || []; this.i = this.path.length>1?1:0; this.recalcT=cfg.botPathRecalc; }
          this.followPath(speed, dt*freeze);
        }
        if(!seen && this.lastSeen){ this.state='search'; this._searchI=0; this._searchPts=this.makeSearchRing(this.lastSeen, 6+Math.min(8,Math.floor(game.level/2))); }
      } else if(this.state==='search'){
        const tgt = (this._searchPts && this._searchPts.length) ? this._searchPts[this._searchI % this._searchPts.length] : this.lastSeen;
        if(tgt){
          if(this.recalcT<=0){ this.path = astar(grid,this.x,this.y,tgt.x,tgt.y) || []; this.i=this.path.length>1?1:0; this.recalcT=cfg.botPathRecalc*1.2; }
          this.followPath(speed, dt*freeze);
          if(Math.hypot(this.x-tgt.x,this.y-tgt.y)<18){ this._searchI++; if(this._searchI>this._searchPts.length*2) this.state='patrol'; }
        } else this.state='patrol';
      } else {
        if(!this.patrol.length) this.setPatrol(grid);
        const t = this.patrol[this._pi % this.patrol.length] || {x:this.x,y:this.y};
        if(this.recalcT<=0){ this.path=astar(grid,this.x,this.y,t.x,t.y) || []; this.i=this.path.length>1?1:0; this.recalcT=cfg.botPathRecalc*1.3; }
        this.followPath(speed, dt*freeze);
        if(Math.hypot(this.x-t.x,this.y-t.y)<18) this._pi=(this._pi||0)+1;
      }
    }
    makeSearchRing(p, n){
      const out=[]; const r=80;
      for(let i=0;i<n;i++){
        const a=i/n*TAU; const x=clamp(p.x+Math.cos(a)*r, BOT_R+8, W()-BOT_R-8);
        const y=clamp(p.y+Math.sin(a)*r, BOT_R+8, H()-BOT_R-8);
        const cell=game.grid.cellOf(x,y); if(!game.grid.isBlocked(cell.gx,cell.gy)) out.push(game.grid.toWorld(cell.gx,cell.gy));
      }
      return out;
    }
    followPath(speed, dt){
      if(!this.path || this.i>=this.path.length){ this.vx=0; this.vy=0; return; }
      const t=this.path[this.i]; const dx=t.x-this.x, dy=t.y-this.y; const d=Math.hypot(dx,dy)||1;
      if(d<6){ this.i++; return; }
      const nx=dx/d, ny=dy/d; this.vx=nx*speed; this.vy=ny*speed;
      let px=this.x+this.vx*dt, py=this.y+this.vy*dt;
      if(px<this.r)px=this.r; if(py<this.r)py=this.r; if(px>W()-this.r)px=W()-this.r; if(py>H()-this.r)py=H()-this.r;
      const obs = game.nearbyObstacles(px,py,this.r+3);
      for(const o of obs){
        if(circleRectCollide(px,py,this.r,o)){
          const tryX=this.x+this.vx*dt; if(!circleRectCollide(tryX,this.y,this.r,o)){ px=tryX; py=this.y; this.vy=0; }
          else { const tryY=this.y+this.vy*dt; if(!circleRectCollide(this.x,tryY,this.r,o)){ py=tryY; px=this.x; this.vx=0; } else { px=this.x; py=this.y; this.vx=0; this.vy=0; } }
        }
      }
      this.x=px; this.y=py;
    }
    seek(tx,ty, speed, dt){ const dx=tx-this.x, dy=ty-this.y, d=Math.hypot(dx,dy)||1; this.vx=dx/d*speed; this.vy=dy/d*speed; this.x+=this.vx*dt; this.y+=this.vy*dt; }
    draw(ctx){
      const x=this.x*scale, y=this.y*scale, r=this.r*scale;
      const color = botColor(this.kind);
      ctx.save();
      if(this.kind==='phase' && Math.hypot(this.vx,this.vy)>5) ctx.globalAlpha=0.12;
      ctx.shadowColor=color; ctx.shadowBlur=14*scale; ctx.fillStyle=color;
      ctx.beginPath();
      for(let i=0;i<6;i++){ const a=i*(TAU/6)+Math.PI/6; const px=x+Math.cos(a)*r, py=y+Math.sin(a)*r; i?ctx.lineTo(px,py):ctx.moveTo(px,py); }
      ctx.closePath(); ctx.fill();
      ctx.restore();
    }
  }

  class PowerUp {
    constructor(x,y,type){ this.x=x; this.y=y; this.r=12; this.type=type; }
    color(){
      return this.type==='slow'?'#bbbbbb'
           : this.type==='freeze'?'#bbddff'
           : this.type==='dash'?'#ffffff'
           : this.type==='shield'?'#66ff99'
           : this.type==='cull'?'#cccccc'
           : this.type==='predator'?'#fffeee'
           : this.type==='cloak'?'#88ffaa'
           : '#ffffff';
    }
    label(){
      return this.type==='slow'?'S'
           : this.type==='freeze'?'F'
           : this.type==='dash'?'D'
           : this.type==='shield'?'P'
           : this.type==='cull'?'X'
           : this.type==='predator'?'R'
           : this.type==='cloak'?'C'
           : '?';
    }
    draw(ctx, t){
      const x=this.x*scale, y=this.y*scale;
      const col=this.color();
      ctx.save();
      ctx.shadowColor=col; ctx.shadowBlur=10*scale; ctx.fillStyle=col; ctx.strokeStyle='#000'; ctx.globalAlpha=0.95;
      const pulse=1+0.08*Math.sin(t*6);
      ctx.beginPath(); ctx.arc(x,y,this.r*scale*pulse,0,TAU); ctx.fill(); ctx.lineWidth=2*scale; ctx.stroke();
      ctx.fillStyle='#000'; ctx.font=`${12*scale}px system-ui,sans-serif`; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(this.label(), x, y+0.5);
      ctx.restore();
    }
  }

  // ---------- game ----------
  const game = {
    // state
    running:false, overlayActive:false, screen:'menu', level:1, time:0,
    sfx:new Sfx(), player:null, bots:[], obstacles:[], powerUps:[], grid:null,
    exitRect:null, debug:false, minimapOn:true, autoMode:false,
    // timers and modifiers
    slowTimer:0, slowTotal:4, freezeTimer:0, freezeTotal:2.5, dashTimer:0, dashTotal:2.2,
    predatorTimer:0, predatorTotal:4, cloakTimer:0, cloakTotal:3.5, shield:0,
    botSpeedMul:1,
    // stealth
    noise:0.5, sneak:false,
    // perf
    onFps(fps){ if(fps<42) setRenderScale(0.75); else if(fps<50) setRenderScale(0.85); else if(fps>58) setRenderScale(1.0); },
    // menus
    showHome(){
      this.screen='menu'; this.running=false; this.overlayActive=true;
      overlay.style.display='flex';
      overlayText.innerHTML = `
        <div class="panel" style="min-width:280px">
          <div style="font-size:24px; margin-bottom:12px">Matrix Hide and Seek</div>
          <div class="col">
            <button id="btnStart">New Run</button>
            <button id="btnDaily">Daily Seed</button>
            <button id="btnScores">Highscores</button>
            <button id="btnSettings">Settings</button>
          </div>
          <div style="opacity:.8; margin-top:10px">WASD or drag. Shift to Sneak. Z Auto. V Minimap. R Restart.</div>
        </div>`;
      setTimeout(()=>{
        document.getElementById('btnStart')?.addEventListener('click', ()=> this.startNewRun());
        document.getElementById('btnDaily')?.addEventListener('click', ()=> this.startDaily());
        document.getElementById('btnScores')?.addEventListener('click', ()=> this.showHighscores());
        document.getElementById('btnSettings')?.addEventListener('click', ()=> this.showSettings());
      },0);
    },
    togglePause(){
      if(this.overlayActive){ overlay.style.display='none'; this.overlayActive=false; return; }
      this.overlayActive=true; overlay.style.display='flex';
      overlayText.innerHTML = `<div class="panel">
        <div style="font-size:20px; margin-bottom:8px">Paused</div>
        <div style="opacity:.8; margin-bottom:10px">Z Auto • Shift Sneak • V Minimap • R Restart • O Settings</div>
        <button id="resume">Resume</button>
      </div>`;
      setTimeout(()=> document.getElementById('resume')?.addEventListener('click',()=>this.togglePause()),0);
    },
    showSettings(){
      this.running=false; this.overlayActive=true; overlay.style.display='flex';
      overlayText.innerHTML = `<div class="panel" style="min-width:280px">
        <div style="font-size:22px; margin-bottom:8px">Settings</div>
        <div class="col" style="text-align:left">
          <label class="switch"><span>Minimap</span><input id="setMM" type="checkbox" ${this.minimapOn?'checked':''}></label>
          <label class="switch"><span>Auto Mode</span><input id="setAuto" type="checkbox" ${this.autoMode?'checked':''}></label>
          <label class="switch"><span>Audio</span><input id="setAudio" type="checkbox" ${!this.sfx.muted?'checked':''}></label>
        </div>
        <div class="row" style="margin-top:10px"><button id="close">Close</button></div>
      </div>`;
      setTimeout(()=>{
        document.getElementById('setMM')?.addEventListener('change', e=>{ this.minimapOn=e.target.checked; minimapEl.style.display=this.minimapOn?'block':'none'; });
        document.getElementById('setAuto')?.addEventListener('change', e=> this.autoMode=e.target.checked);
        document.getElementById('setAudio')?.addEventListener('change', e=> this.sfx.toggleMute());
        document.getElementById('close')?.addEventListener('click', ()=>{ overlay.style.display='none'; this.overlayActive=false; this.running=true; });
      },0);
    },
    getScores(){ try{ return JSON.parse(localStorage.getItem('mhs_scores')||'[]'); }catch{return [];} },
    saveScores(arr){ try{ localStorage.setItem('mhs_scores', JSON.stringify(arr)); }catch{} },
    qualifies(score){ const arr=this.getScores(); if(arr.length<5) return true; return score>Math.min(...arr.map(s=>s.score)); },
    promptHigh(score){
      this.overlayActive=true; overlay.style.display='flex';
      overlayText.innerHTML = `<div class="panel" style="min-width:260px">
        <div style="font-size:18px; margin-bottom:8px">Top 5. Enter name</div>
        <div style="opacity:.85; margin-bottom:8px">Score ${score}</div>
        <input id="name" maxlength="12" placeholder="Your name" style="width:100%; padding:8px; font-size:16px; margin-bottom:10px;">
        <div class="row">
          <button id="save" style="flex:1">Save</button><button id="skip">Skip</button>
        </div>
      </div>`;
      setTimeout(()=>{
        const inp=document.getElementById('name'); inp?.focus();
        document.getElementById('save')?.addEventListener('click', ()=>{
          const arr=this.getScores(); arr.push({ name:String(inp.value||'---').slice(0,12), score:score|0 });
          arr.sort((a,b)=>b.score-a.score); if(arr.length>5) arr.length=5; this.saveScores(arr); this.showHighscores();
        });
        document.getElementById('skip')?.addEventListener('click', ()=> this.showHome());
      },0);
    },
    showHighscores(){
      this.overlayActive=true; overlay.style.display='flex';
      const arr=this.getScores();
      const rows = arr.length ? arr.map((r,i)=>`<div style="display:flex; justify-content:space-between"><span>${i+1}. ${r.name}</span><span>${r.score}</span></div>`).join('') : "<div style='opacity:.8'>No highscores yet.</div>";
      overlayText.innerHTML = `<div class="panel" style="min-width:260px">
        <div style="font-size:22px; margin-bottom:8px">Highscores</div>
        <div style="display:flex; flex-direction:column; gap:6px; text-align:left; margin-bottom:12px">${rows}</div>
        <button id="back">Back</button>
      </div>`;
      setTimeout(()=> document.getElementById('back')?.addEventListener('click', ()=> this.showHome()),0);
    },
    // seed
    seed: (Date.now()>>>8)&0xffffffff,
    startDaily(){
      const d=new Date(); const key = Number(`${d.getUTCFullYear()}${String(d.getUTCMonth()+1).padStart(2,'0')}${String(d.getUTCDate()).padStart(2,'0')}`);
      this.seed = key; this.startNewRun();
    },
    // build level
    buildLevel(level){
      this.time=0; this.level=level;
      this.cfg = genConfig(level);
      this.obstacles = makeObstacles(this.cfg.obstacleCount);
      // occasionally one teleporting obstacle
      if(level>=3 && Math.random()<0.5){
        const o = choice(this.obstacles); if(o){ o.type='tele'; o.timer=1.5+rnd(0,1.5); }
      }
      this.rebuildObsIndex();

      const p0 = randomFreePoint(this.obstacles, PLAYER_R);
      this.player = new Player(p0);

      // exit
      const exitSize = GRID*3; let ex=null;
      for(let t=0;t<200;t++){
        const r={ x:rnd(10, W()-exitSize-10), y:rnd(10, H()-exitSize-10), w:exitSize, h:exitSize };
        let bad=false; for(const o of this.obstacles){ if(rectsIntersect(r,o)){ bad=true; break; } }
        if(!bad){ ex=r; break; }
      }
      this.exitRect = ex || { x:W()-exitSize-10, y:H()-exitSize-10, w:exitSize, h:exitSize };

      // bots
      this.bots.length=0;
      const totalBots = Math.max(1, level|0);
      const specials = ['stalker','phase'];
      const specialCount = Math.min(Math.max(0, Math.round(totalBots*0.25)), totalBots-1);
      const bag = Array(totalBots-specialCount).fill('hunter').concat(Array(specialCount).fill(0).map(()=>choice(specials)));
      for(let i=bag.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [bag[i],bag[j]]=[bag[j],bag[i]]; }
      const minPlayerD = Math.max(300, this.cfg.botSightRange*0.75);
      for(const k of bag){
        let pos=null;
        for(let t=0;t<400;t++){
          const c=randomFreePoint(this.obstacles, BOT_R);
          if(dist2(c.x,c.y,this.player.x,this.player.y) < minPlayerD*minPlayerD) continue;
          let ok=true; for(const b of this.bots){ if(dist2(c.x,c.y,b.x,b.y) < (BOT_R*6)*(BOT_R*6)){ ok=false; break; } }
          if(!ok) continue;
          pos=c; break;
        }
        if(!pos) pos=randomFreePoint(this.obstacles, BOT_R);
        const b=new Bot(pos,k); this.bots.push(b);
      }

      // grid
      const maxR = Math.max(BOT_R, ...this.bots.map(b=>b.r));
      this.grid = new Grid(this.obstacles, maxR);

      // powerups
      this.powerUps.length=0;
      const pool = ['slow','freeze','dash','shield','cull','predator','cloak'];
      for(let k=0;k<2;k++){
        const pos = randomFreePoint(this.obstacles, 14);
        if(dist2(pos.x,pos.y,this.player.x,this.player.y) < (48+PLAYER_R+12)**2){ k--; continue; }
        if(circleRectCollide(pos.x,pos.y,14,this.exitRect)) { k--; continue; }
        let near=false; for(const b of this.bots){ if(dist2(pos.x,pos.y,b.x,b.y) < (48+BOT_R+12)**2){ near=true; break; } }
        if(near){ k--; continue; }
        this.powerUps.push(new PowerUp(pos.x, pos.y, pool.splice((Math.random()*pool.length)|0,1)[0]));
      }

      // timers and flags
      this.botSpeedMul = 1; this.slowTimer=0; this.freezeTimer=0; this.dashTimer=0;
      this.predatorTimer=0; this.cloakTimer=0; this.shield=0;

      // visuals and audio
      this.sfx.init();
      this.running=true;
    },
    startNewRun(){ overlay.style.display='none'; this.overlayActive=false; this.screen='play'; this.level=1; this.buildLevel(1); this.running=true; },
    resetLevel(){ this.buildLevel(this.level); },
    nextLevel(){ this.level++; this.buildLevel(this.level); this.flashMessage(`Matrix ${this.level} loaded`); haptics(18); },
    flashMessage(text){
      this.overlayActive=true; overlay.style.display='flex';
      overlayText.innerHTML = `<div class="panel">${text}<div style="margin-top:8px; opacity:.75">Tap or key to continue</div></div>`;
      const close=()=>{ overlay.style.display='none'; this.overlayActive=false; window.removeEventListener('keydown',close,true); window.removeEventListener('pointerdown',close,true); };
      window.addEventListener('keydown', close, true); window.addEventListener('pointerdown', close, true);
      setTimeout(close, 2000);
    },
    // obstacle index for quick queries
    rebuildObsIndex(){
      const cs=96; const cols=Math.max(1, Math.ceil(W()/cs)), rows=Math.max(1, Math.ceil(H()/cs));
      const cells=new Array(cols*rows); for(let i=0;i<cells.length;i++) cells[i]=[];
      const key=(gx,gy)=> gy*cols+gx;
      for(const o of this.obstacles){
        const gx0=Math.floor(o.x/cs), gy0=Math.floor(o.y/cs);
        const gx1=Math.floor((o.x+o.w)/cs), gy1=Math.floor((o.y+o.h)/cs);
        for(let gy=gy0; gy<=gy1; gy++) for(let gx=gx0; gx<=gx1; gx++){
          if(gx>=0&&gy>=0&&gx<cols&&gy<rows) cells[key(gx,gy)].push(o);
        }
      }
      this.obsIndex={ cs, cols, rows, cells, qid:1 };
    },
    nearbyObstacles(x,y,r){
      if(!this.obsIndex) return this.obstacles;
      const { cs, cols, rows, cells } = this.obsIndex;
      const gx0=Math.floor((x-r)/cs), gy0=Math.floor((y-r)/cs);
      const gx1=Math.floor((x+r)/cs), gy1=Math.floor((y+r)/cs);
      const out=[]; const qid=++this.obsIndex.qid;
      for(let gy=gy0; gy<=gy1; gy++) for(let gx=gx0; gx<=gx1; gx++){
        if(gx<0||gy<0||gx>=cols||gy>=rows) continue;
        for(const o of cells[gy*cols+gx]){ if(o._qid===qid) continue; o._qid=qid; out.push(o); }
      }
      return out.length?out:this.obstacles;
    },
    // step
    update(dt){
      this.time+=dt;
      hudLevel.textContent = `Matrix ${this.level}`;
      // input state
      this.sneak = keys.has('shift') || keys.has('shiftleft') || (this.autoMode && this.distToNearestBot()<180);

      // move teleporters and movers
      this.stepObstacles(dt);

      // player
      this.player.update(dt, this.cfg);
      const pSp = Math.hypot(this.player.vx, this.player.vy);

      // noise and cover
      const near = this.nearbyObstacles(this.player.x, this.player.y, 72);
      let cover=0; for(const o of near){ if(circleRectCollide(this.player.x,this.player.y,40,o)) cover+=0.5; }
      cover = clamp(cover,0,1);
      const baseNoise = clamp(pSp/(this.cfg.playerMaxSpeed||1), 0, 1);
      const sneakMod = this.sneak ? 0.55 : 1.0;
      this.noise = clamp(baseNoise*0.9*sneakMod - 0.35*cover, 0.08, 1.0);
      stealthFill.style.width = Math.round(this.noise*100)+'%';

      // timers tick only while providing input
      const inputActive = hasActiveInput();
      const dtm = dt*(inputActive?1:0);
      if(this.slowTimer>0){ this.slowTimer-=dtm; if(this.slowTimer<=0) this.botSpeedMul=1; }
      if(this.freezeTimer>0){ this.freezeTimer-=dtm; }
      if(this.dashTimer>0){ this.dashTimer-=dtm; }
      if(this.predatorTimer>0){ this.predatorTimer-=dtm; }
      if(this.cloakTimer>0){ this.cloakTimer-=dtm; }

      const anyTimer = this.slowTimer>0 || this.freezeTimer>0 || this.dashTimer>0 || this.predatorTimer>0 || this.cloakTimer>0;
      if(anyTimer){ this.sfx.tickStart(); } else { this.sfx.tickStop(); }

      // bots
      for(const b of this.bots){
        const pre=b.state; b.update(dt, this.cfg);
        if(pre!=='chase' && b.state==='chase') this.sfx.alert();
      }

      // exit
      if(circleRectCollide(this.player.x,this.player.y,this.player.r,this.exitRect)){ this.sfx.exit(); this.nextLevel(); }

      // powerups
      for(let i=this.powerUps.length-1;i>=0;i--){
        const pu=this.powerUps[i]; if(Math.hypot(this.player.x-pu.x,this.player.y-pu.y) < this.player.r+pu.r){
          this.applyPowerup(pu.type); this.powerUps.splice(i,1); this.sfx.click(); haptics(18);
        }
      }

      // collisions
      let caught=false, hitBot=null;
      if(this.predatorTimer>0){
        for(let i=this.bots.length-1;i>=0;i--){
          const b=this.bots[i];
          if(Math.hypot(this.player.x-b.x,this.player.y-b.y) < this.player.r+b.r-2){ this.bots.splice(i,1); }
        }
      } else if(this.cloakTimer<=0){
        for(const b of this.bots){ if(Math.hypot(this.player.x-b.x,this.player.y-b.y) < this.player.r+b.r-2){ caught=true; hitBot=b; break; } }
      }
      if(caught){
        if(this.shield>0){ this.shield--; haptics(20); }
        else {
          this.running=false; this.sfx.caught();
          const score = this.level*100 + Math.min(99, Math.floor(this.time));
          this.qualifies(score) ? this.promptHigh(score) : this.showHome();
        }
      }

      // HUD
      hudStatus.textContent = this.autoMode ? (this.sneak ? 'AUTO • SNEAK' : 'AUTO') : (this.sneak ? 'SNEAK' : '');
    },
    applyPowerup(type){
      if(type==='slow'){ this.botSpeedMul=0.55; this.slowTimer=this.slowTotal; }
      else if(type==='freeze'){ this.freezeTimer=this.freezeTotal; }
      else if(type==='dash'){ this.dashTimer=this.dashTotal; }
      else if(type==='cull'){ if(this.bots.length) this.bots.pop(); }
      else if(type==='predator'){ this.predatorTimer=this.predatorTotal; }
      else if(type==='shield'){ this.shield=(this.shield||0)+1; }
      else if(type==='cloak'){ this.cloakTimer=this.cloakTotal; }
    },
    // dynamic obstacles
    stepObstacles(dt){
      let teleported=false;
      for(const o of this.obstacles){
        if(o.type==='move'){
          if(!hasActiveInput()) continue;
          o.offset = (o.offset||0) + o.dir*o.speed*dt;
          if(o.offset>o.range || o.offset<-o.range){ o.dir*=-1; o.offset=clamp(o.offset,-o.range,o.range); }
          if(o.axis==='x') o.x = o.baseX + o.offset; else o.y = o.baseY + o.offset;
        } else if(o.type==='tele'){
          o.timer = (o.timer||1.5) - dt*(hasActiveInput()?1.0:0.5);
          if(o.timer<=0){
            const cs=GRID; let found=null;
            for(let tries=0; tries<500; tries++){
              const cw=Math.max(1, Math.round(o.w/cs)), ch=Math.max(1, Math.round(o.h/cs));
              const gx=2+rndInt(0, Math.floor(W()/cs)-cw-4), gy=2+rndInt(0, Math.floor(H()/cs)-ch-4);
              const nx=gx*cs, ny=gy*cs; const c={x:nx,y:ny,w:o.w,h:o.h};
              let bad=false;
              for(const other of this.obstacles){ if(other===o) continue; if(!(c.x-2+c.w+4<other.x||other.x+other.w<c.x-2||c.y-2+c.h+4<other.y||other.y+other.h<c.y-2)){ bad=true; break; } }
              if(bad) continue;
              if(circleRectCollide(this.player.x,this.player.y,this.player.r+4,c)) bad=true;
              if(!bad) for(const b of this.bots){ if(circleRectCollide(b.x,b.y,b.r+4,c)){ bad=true; break; } }
              if(bad) continue;
              if(rectsIntersect({x:c.x-6,y:c.y-6,w:c.w+12,h:c.h+12}, this.exitRect)) bad=true;
              if(!bad){ found=c; break; }
            }
            if(found){ o.x=found.x; o.y=found.y; teleported=true; }
            o.timer = 1.5 + Math.random()*2.0;
          }
        }
      }
      if(teleported){ const maxR=Math.max(BOT_R, ...this.bots.map(b=>b.r)); this.grid = new Grid(this.obstacles, maxR); this.rebuildObsIndex(); for(const b of this.bots){ b.path=[]; b.i=0; } }
    },
    // draw
    draw(){
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // background radial + faint grid + code rain
      drawBackground(ctx, this.time);

      // obstacles
      for(const o of this.obstacles) drawObstacle(ctx,o,this.time);

      // exit spiral
      drawExit(ctx, this.exitRect, this.time);

      // powerups
      for(const pu of this.powerUps) pu.draw(ctx, this.time);

      // entities
      this.player.draw(ctx);
      for(const b of this.bots) b.draw(ctx);

      // timers ring around player
      const px=this.player.x*scale, py=this.player.y*scale, rr=this.player.r*scale+8*scale;
      ctx.save(); ctx.lineWidth=3*scale; ctx.globalAlpha=0.95; ctx.lineCap='round';
      ring(this.slowTimer,this.slowTotal,'#bbbbbb',0);
      ring(this.freezeTimer,this.freezeTotal,'#bbddff',Math.PI*0.33);
      ring(this.dashTimer,this.dashTotal,'#ffffff',Math.PI*0.66);
      ring(this.predatorTimer,this.predatorTotal,'#ffffff',Math.PI*1.00);
      ring(this.cloakTimer,this.cloakTotal,'#88ffaa',Math.PI*1.33);
      ctx.restore();
      function ring(timer,total,col,ofs){ if(!(timer>0&&total)) return; const f=clamp(timer/total,0,1); ctx.strokeStyle=col; const a0=ofs+game.time*1.6, a1=a0+f*TAU; ctx.beginPath(); ctx.arc(px,py,rr,a0,a1); ctx.stroke(); }

      // joystick
      if(joystick.active){
        ctx.save(); ctx.fillStyle='rgba(255,255,255,0.2)';
        ctx.beginPath(); ctx.arc(joystick.cx*scale,joystick.cy*scale,joystick.radius*scale,0,TAU); ctx.fill();
        ctx.fillStyle='rgba(255,255,255,0.35)';
        ctx.beginPath(); ctx.arc(joystick.x*scale,joystick.y*scale,(joystick.radius*0.45)*scale,0,TAU); ctx.fill(); ctx.restore();
      }

      // debug FOV
      if(this.debug){
        const cfg=this.cfg;
        for(const b of this.bots){
          const bx=b.x*scale, by=b.y*scale; const heading=Math.atan2(b.vy||0.0001,b.vx||0.0001); const range=cfg.botSightRange*scale;
          ctx.save(); ctx.globalAlpha=0.18; ctx.fillStyle='#ff2a2a';
          ctx.beginPath(); ctx.moveTo(bx,by); ctx.arc(bx,by,range, heading-cfg.botFOV*0.5, heading+cfg.botFOV*0.5); ctx.closePath(); ctx.fill(); ctx.restore();
          ctx.save(); ctx.globalAlpha=0.35; ctx.strokeStyle='#ff8080'; ctx.beginPath(); ctx.moveTo(bx,by); ctx.lineTo(this.player.x*scale, this.player.y*scale); ctx.stroke(); ctx.restore();
          if(b.path && b.path.length>1){
            ctx.save(); ctx.strokeStyle='#66ccff'; ctx.globalAlpha=0.6; ctx.lineWidth=1.5*scale; ctx.beginPath(); ctx.moveTo(b.x*scale,b.y*scale);
            const stride=Math.max(1, Math.ceil(b.path.length/80));
            for(let i=0;i<b.path.length;i+=stride){ const n=b.path[i]; ctx.lineTo(n.x*scale,n.y*scale); }
            const last=b.path[b.path.length-1]; if(last) ctx.lineTo(last.x*scale,last.y*scale); ctx.stroke(); ctx.restore();
          }
        }
      }

      // minimap
      if(this.minimapOn) drawMinimap(this);
    },
    distToNearestBot(){
      let m=1e9; for(const b of this.bots){ const d=Math.hypot(b.x-this.player.x,b.y-this.player.y); if(d<m) m=d; } return m;
    }
  };

  // ---------- helpers ----------
  function genConfig(level){
    const mobile = isCoarsePointer() || (Math.min(window.innerWidth, window.innerHeight) < 820);
    const runs = Number(localStorage.getItem('mhs_runs')||0);
    const diffMul = runs===0 ? 0.9 : Math.min(1.5, 1 + runs*0.06);
    return {
      playerSpeed:   mobile ? 3000 : (1800 + Math.min(600, level*120)),
      playerFriction:mobile ? 0.90 : 0.93,
      playerMaxSpeed:mobile ? 800  : (420 + Math.min(180, level*20)),
      botPathRecalc: Math.max(0.06, (0.32 - level*0.02) / diffMul),
      botSightRange: (240 + level*12) * diffMul,
      botFOV: Math.PI*0.75,
      botHearing: (110 + level*8) * diffMul,
      obstacleCount: Math.round((8 + Math.min(22, Math.floor(level*1.6))) * (runs===0?0.9:Math.min(1.35, 1 + runs*0.04)))
    };
  }
  function makeObstacles(count){
    const cs=GRID; const obs=[]; let tries=0;
    while(obs.length<count && tries<count*40){
      tries++;
      const cw=rndInt(3, Math.max(3, Math.min(9, Math.floor(W()/cs/3))));
      const ch=rndInt(2, Math.max(2, Math.min(7, Math.floor(H()/cs/3))));
      const w=cw*cs, h=ch*cs;
      const gx=rndInt(2, Math.max(2, Math.floor(W()/cs)-cw-3));
      const gy=rndInt(2, Math.max(2, Math.floor(H()/cs)-ch-3));
      const r={ x:gx*cs, y:gy*cs, w, h, type:'static' };
      let ok=true; for(const o of obs){ const gap=cs*0.6;
        if(!(r.x-gap+r.w+gap<o.x || o.x+o.w<r.x-gap || r.y-gap+r.h+gap<o.y || o.y+o.h<r.y-gap)){ ok=false; break; }
      }
      if(!ok) continue;
      // sometimes a mover
      const pMove=Math.min(0.35, 0.12 + (game.level||1)*0.02);
      if(Math.random()<pMove){
        r.type='move'; r.axis=Math.random()<0.5?'x':'y';
        r.baseX=r.x; r.baseY=r.y; r.range=r.axis==='x'? rndInt(2,4)*cs : rndInt(2,3)*cs;
        r.offset=0; r.dir=Math.random()<0.5?-1:1; r.speed=220; // scaled by input
      }
      obs.push(r);
    }
    return obs;
  }
  function randomFreePoint(obstacles, radius){
    for(let t=0;t<2000;t++){
      const x=radius+8+rnd(0, W()-2*radius-16), y=radius+8+rnd(0, H()-2*radius-16);
      let bad=false; for(const o of obstacles){ if(circleRectCollide(x,y,radius+3,o)){ bad=true; break; } }
      if(!bad) return {x,y};
    }
    return {x:radius+16, y:radius+16};
  }
  function hasActiveInput(){
    if(joystick.active && joystick.mag>0.02) return true;
    if(keys.has('arrowleft')||keys.has('a')) return true;
    if(keys.has('arrowright')||keys.has('d')) return true;
    if(keys.has('arrowup')||keys.has('w')) return true;
    if(keys.has('arrowdown')||keys.has('s')) return true;
    return false;
  }

  // ---------- visuals ----------
  function drawBackground(ctx, t){
    const cx=(game.player?.x||W()*0.5)*scale, cy=(game.player?.y||H()*0.5)*scale;
    const r=Math.hypot(canvas.width,canvas.height)*0.6;
    const g=ctx.createRadialGradient(cx,cy,0,cx,cy,r);
    g.addColorStop(0,'#101010'); g.addColorStop(1,'#000000');
    ctx.fillStyle=g; ctx.fillRect(0,0,canvas.width,canvas.height);
    // faint grid
    ctx.save(); ctx.globalAlpha=0.035; ctx.strokeStyle='#ffffff';
    const s=Math.max(36*scale, Math.min(canvas.width,canvas.height)/18), off=(t*15)%s;
    ctx.beginPath(); for(let x=off;x<canvas.width;x+=s){ ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
    for(let y=off;y<canvas.height;y+=s){ ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); } ctx.stroke(); ctx.restore();
    // code rain
    drawCodeRain(ctx, t);
  }
  const codeCols = [];
  function initCodeCols(){
    codeCols.length=0;
    const cs=14; const cols=Math.max(12, Math.floor(W()/(cs*1.2)));
    for(let i=0;i<cols;i++) codeCols.push({ x:(i+0.5)*cs*1.2, y:Math.random()*-H(), speed:60+Math.random()*140, gap:Math.floor(8+Math.random()*16), seed:Math.random()*1000 });
  }
  function drawCodeRain(ctx, t){
    if(!codeCols.length) initCodeCols();
    const g='01ABCDEFGHIJKLMNOPQRSTUVWXYZ'; const cs=14*scale;
    ctx.save(); ctx.globalAlpha=0.12; ctx.font = `${cs}px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace`; ctx.textAlign='center'; ctx.textBaseline='top';
    for(const c of codeCols){
      c.y += c.speed*(1/60);
      if(c.y > H()+80) { c.y = -Math.random()*H(); c.speed=60+Math.random()*140; }
      const x=c.x*scale;
      for(let k=-20;k<40;k++){
        const y=(c.y + k*c.gap)*scale; if(y<-40 || y>canvas.height+40) continue;
        const ch = g[(k + Math.floor(t*10) + ((c.seed*37)|0)) % g.length];
        ctx.fillStyle = k===0 ? 'rgba(160,255,200,0.9)' : 'rgba(80,220,160,0.45)';
        ctx.fillText(ch, x, y);
      }
    }
    ctx.restore();
  }
  function drawObstacle(ctx, o, time){
    const x=o.x*scale, y=o.y*scale, w=o.w*scale, h=o.h*scale;
    ctx.fillStyle='rgba(255,255,255,0.10)'; ctx.fillRect(x,y,w,h);
    const flick=0.11 + 0.14*Math.abs(Math.sin(time*6.0 + ((o.x*19.31+o.y*11.73)/97.3)));
    ctx.save(); ctx.globalAlpha=flick; ctx.fillStyle='#ffffff'; ctx.fillRect(x+1,y+1,w-2,h-2); ctx.restore();
    ctx.save(); ctx.globalAlpha=0.18 + 0.35*flick; ctx.strokeStyle='#ffffff'; ctx.lineWidth=2*scale; ctx.strokeRect(x+1,y+1,w-2,h-2); ctx.restore();
  }
  function drawExit(ctx, ex, t){
    if(!ex) return;
    ctx.save();
    const cx=(ex.x+ex.w*0.5)*scale, cy=(ex.y+ex.h*0.5)*scale, es=Math.min(ex.w,ex.h)*scale;
    ctx.translate(cx,cy); ctx.rotate(t*0.9);
    const turns=4.5, maxR=es*0.48, minR=es*0.06; const a=minR, b=(maxR-minR)/(TAU*turns);
    ctx.lineWidth=2.2*scale; ctx.strokeStyle='#ffffff'; ctx.globalAlpha=0.9;
    ctx.beginPath(); const steps=360;
    for(let i=0;i<=steps;i++){ const th=(i/steps)*(TAU*turns); const r=a+b*th; const x=Math.cos(th)*r, y=Math.sin(th)*r; i?ctx.lineTo(x,y):ctx.moveTo(x,y); }
    ctx.stroke(); ctx.restore();
  }
  function drawMinimap(gm){
    const w=minimapEl.width, h=minimapEl.height;
    mm.clearRect(0,0,w,h);
    mm.fillStyle='rgba(255,255,255,0.06)'; mm.fillRect(0,0,w,h);
    const sx=w/W(), sy=h/H();
    // obstacles
    mm.save(); mm.fillStyle='rgba(255,255,255,0.18)';
    for(const o of gm.obstacles){ mm.fillRect(o.x*sx, o.y*sy, o.w*sx, o.h*sy); }
    mm.restore();
    // exit
    mm.save(); mm.globalAlpha=0.9; mm.strokeStyle='#ffffff'; const ex=gm.exitRect; mm.strokeRect(ex.x*sx, ex.y*sy, ex.w*sx, ex.h*sy); mm.restore();
    // powerups
    for(const pu of gm.powerUps){ mm.fillStyle=pu.color(); mm.globalAlpha=0.9; mm.fillRect(pu.x*sx-2, pu.y*sy-2, 4,4); }
    // bots
    for(const b of gm.bots){ mm.fillStyle=botColor(b.kind); mm.globalAlpha=0.85; mm.fillRect(b.x*sx-2, b.y*sy-2, 4,4); }
    // player
    mm.fillStyle='#ffffff'; mm.globalAlpha=1; mm.fillRect(gm.player.x*sx-2, gm.player.y*sy-2, 4,4);
  }

  // ---------- input vector ----------
  function inputVector(){
    if(game.autoMode && game.screen==='play' && game.running && !game.overlayActive){
      const [vx,vy] = autoSteer(); const L=Math.hypot(vx,vy)||1; return [vx/L, vy/L, 1];
    }
    let ax=0, ay=0;
    if(keys.has('arrowleft')||keys.has('a')) ax -= 1;
    if(keys.has('arrowright')||keys.has('d')) ax += 1;
    if(keys.has('arrowup')||keys.has('w')) ay -= 1;
    if(keys.has('arrowdown')||keys.has('s')) ay += 1;
    if(joystick.active){ ax += joystick.vec[0]*joystick.mag; ay += joystick.vec[1]*joystick.mag; }
    if(ax||ay){ const l=Math.hypot(ax,ay); return [ax/l, ay/l, Math.min(1,l)]; }
    return [0,0,0];
  }
  // simple auto planner toward exit while curving away from threats
  function autoSteer(){
    const p=game.player, ex=game.exitRect; const tx=ex.x+ex.w*0.5, ty=ex.y+ex.h*0.5;
    let vx=tx-p.x, vy=ty-p.y; const bl=Math.hypot(vx,vy)||1; vx/=bl; vy/=bl;
    const Rb=220, kB=22000; let fleeX=0, fleeY=0;
    for(const b of game.bots){
      const dx=p.x-b.x, dy=p.y-b.y; const d2=dx*dx+dy*dy; if(d2<Rb*Rb){ const w=kB/d2; fleeX+=dx*w; fleeY+=dy*w; }
    }
    const Lf=Math.hypot(fleeX,fleeY)||1; fleeX/=Lf; fleeY/=Lf;
    const pvx = -vy, pvy = vx;
    const dot = fleeX*pvx + fleeY*pvy;
    const curve=0.5;
    vx += pvx*dot*curve; vy += pvy*dot*curve;
    // waypoint if LOS blocked
    const los = game.grid.losClear(p.x,p.y,tx,ty,game.obstacles);
    if(!los){
      const path = astar(game.grid,p.x,p.y,tx,ty);
      if(path && path.length>1){ const i=Math.min(2, path.length-1); const w=path[i]; const wx=w.x-p.x, wy=w.y-p.y; const l=Math.hypot(wx,wy)||1; vx += (wx/l)*0.35; vy += (wy/l)*0.35; }
    }
    return [vx,vy];
  }

  // ---------- main loop ----------
  let last=performance.now(), acc=0, frames=0, fps=0, fpsTimer=0;
  const DT=1/60;
  function loop(t){
    requestAnimationFrame(loop);
    const elapsed=Math.min(0.25, (t-last)/1000); last=t; acc+=elapsed;
    while(acc>=DT){ if(game.running && !game.overlayActive) game.update(DT); acc-=DT; }
    game.draw();
    frames++; fpsTimer+=elapsed; if(fpsTimer>=0.5){ fps=Math.round(frames/fpsTimer); frames=0; fpsTimer=0; hudFps.textContent=`${fps} fps`; game.onFps(fps); }
  }

  // ---------- startup ----------
  function init(){
    game.showHome();
    window.game=game;
    requestAnimationFrame(loop);
    if('serviceWorker' in navigator){ /* optional: skip registration to keep file simple */ }
    localStorage.setItem('mhs_runs', String(Number(localStorage.getItem('mhs_runs')||0)+1));
  }
  init();

  // ---------- UI actions ----------
  // none here, handled in game.showHome

})();
</script>
</body>
</html>
